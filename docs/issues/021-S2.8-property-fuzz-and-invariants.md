---
id: S2.8
title: "Property/Fuzz & Invariants"
epic: "E5 - Security & QA"
sprint: "Sprint 2"
estimate: 8
labels: ["security", "tests", "sprint-2"]
assignees: ["be2"]
dependencies: ["S1.3", "S2.1", "S2.3"]
status: "done"
---

## Solana Migration: Property-Based & Invariant Testing

### Context
Migrate EVM fuzzing/invariant tests sang Solana testing framework:
- **Option 1**: Rust-native với `solana-program-test` + `proptest` (property-based testing)
- **Option 2**: Expand TypeScript tests với Anchor framework, nhiều randomized test cases
- Bảo toàn financial invariants: conservation of funds, overflow protection, claim limits
- Critical cho security: verify không có fund leakage qua arbitrary action sequences

### Scope (Solana)
**Core Invariant - Fund Conservation**:
```
∀ round (settled):
  Σ(winners_claims) ≤ distributable_pool
  where distributable_pool = total_revealed_stake - commit_fees - settle_fee
```

**Excluded from invariant** (by design):
- Tie refunds (returned immediately, không vào winners pool)
- Non-revealer penalty refunds (partial return sau reveal phase)
- Treasury penalties (routed separately, không affect distributable)

**Testing scope**:
- Native SOL mode (`stake_token = None`)
- SPL Token mode (`stake_token = Some(mint)`)
- Fuzzed action sequences: commit → reveal → warp time → settle → claim (random orders, amounts, players)

### Acceptance Criteria
- ✅ Invariant test suites pass với N runs (minimum 256 runs per suite)
- ✅ Native SOL invariants hold: no fund over-distribution
- ✅ SPL Token invariants hold: token accounting correct
- ✅ No panics/overflows qua fuzzed inputs (stake amounts, player counts, timing)
- ✅ Edge cases covered: empty rounds, all ties, single player, max players
- ✅ Integration vào CI pipeline: automated regression testing

### Tasks

#### 1. **State Helper Functions**
- Implement account readers cho Solana program state:
  - `get_round_pools()`: read `total_revealed_stake`, `commit_fees`, `settle_fee`
  - `get_round_meta()`: read `num_winners`, `num_players`, `settlement_status`
  - `get_player_commitment()`: read individual player state
- Anchor IDL type wrappers cho TypeScript tests

#### 2. **Rust Property-Based Tests** (Option 1)
- Setup `proptest` strategies:
  - `arb_stake_amount()`: generate valid stake amounts (min_stake..max_stake)
  - `arb_player_actions()`: generate commit/reveal sequences
  - `arb_choice()`: generate valid choices (0..max_choice)
- Implement invariant checks:
  - `assert_fund_conservation()`: verify Σ claims ≤ distributable
  - `assert_no_overflow()`: check u64 arithmetic safety
- Integrate với `solana-program-test` harness

#### 3. **TypeScript Extended Tests** (Option 2)
- Expand `tests/chocochoco.ts` với fuzzing utilities:
  - Random player generation (5-50 players per test)
  - Random stake amounts within bounds
  - Random reveal timings (some late, some on-time)
- Matrix testing: {native, SPL} × {winner, loser, tie, non-revealer} cases
- Run 100+ iterations per test scenario

#### 4. **Invariant Validation Logic**
```rust
// Pseudo-code
fn check_invariant(round_pda: &AccountInfo) {
    let pools = get_round_pools(round_pda);
    let meta = get_round_meta(round_pda);
    
    let distributable = pools.total_revealed_stake 
        - pools.commit_fees 
        - pools.settle_fee;
    
    let actual_claims = sum_all_winner_claims(round_pda);
    
    assert!(actual_claims <= distributable, "Invariant violated");
}
```

#### 5. **CI Integration**
- Add test commands to `.github/workflows/`:
  - `anchor test -- --features invariant-tests`
  - Timeout: 10 minutes (để chạy 256+ iterations)
- Failure reporting: log invariant violations với full state dump

### Result
- **Ported invariant test suite** từ Foundry sang Solana:
  - Rust implementation: `tests/invariants.rs` với `proptest` (256 runs)
    - Strategy generators cho stake amounts, player actions, timing
    - Invariant checker: `assert_fund_conservation_invariant()`
  - TypeScript implementation: `tests/invariants-fuzz.ts` (alternative, 128 runs)
    - Randomized multi-player scenarios
    - Both native SOL và SPL Token paths
- **State helper functions** added:
  - `get_round_pools()`: expose pool accounting for verification
  - `get_round_meta()`: expose settlement metadata
  - `get_player_state()`: individual commitment/claim tracking
- **Invariant coverage**:
  - Fund conservation: ✅ no over-distribution detected (256/256 runs pass)
  - Overflow safety: ✅ u64 arithmetic checked
  - Edge cases: ✅ empty rounds, all-tie, single-player handled correctly

### Tests
- **`test_invariant_native_sol_fuzz`** (Rust):
  - Generates 256 random game scenarios (varying players, stakes, choices)
  - Each iteration: commit → reveal → settle → verify invariant
  - Checks: `Σ winner_claims ≤ total_revealed - fees`
  - Result: **256/256 pass**
  
- **`test_invariant_spl_token_fuzz`** (Rust):
  - Same as above, SPL Token mode
  - Validates token program CPI accounting
  - Result: **256/256 pass**

- **`test_property_no_overflow`** (Rust):
  - Fuzzes extreme stake amounts (near u64::MAX)
  - Verifies no panics in pool accumulation
  - Result: **128/128 pass**

- **TypeScript extended tests** (alternative):
  - `tests/invariants-fuzz.ts`: 128 iterations per mode
  - Mixed action sequences: late reveals, partial settlements, concurrent claims
  - Result: **All pass (native + SPL)**

**Total coverage**: 640+ fuzzed iterations across all suites (CI runs daily)

### Migration Notes

**EVM → Solana differences**:
- **Foundry `StdInvariant`** → **proptest strategies** + custom harness
  - EVM: contract handlers fuzz function calls automatically
  - Solana: manual strategy generation với `prop_compose!` macros
- **View helpers**:
  - EVM: `getRoundPools()`, `getRoundMeta()` callable from test contract
  - Solana: direct account deserialization or CPI helpers
- **Overflow behavior**:
  - EVM: Solidity reverts on overflow (safe by default)
  - Solana: Rust uses checked arithmetic (`checked_add()` explicit)

**Security improvements**:
- Solana's account model prevents re-entrancy by design (no cross-contract reentrancy risk)
- Explicit PDA ownership checks enforce invariants at runtime (vs. EVM's implicit contract boundaries)
- Token Program's `transfer_checked()` validates decimals/mint (stronger than ERC-20 safeTransfer)

### CI Configuration
```yaml
# .github/workflows/invariant-tests.yml
- name: Run Invariant Tests (Rust)
  run: |
    cd solana
    cargo test-sbf --features invariant-tests -- --nocapture
    
- name: Run Invariant Tests (TypeScript)
  run: |
    cd solana
    anchor test tests/invariants-fuzz.ts
```

**Run frequency**: Daily scheduled + on every PR to main
